---
title: "RustMapper: White Pine Blister Rust (WPBR) Risk"
format: 
  dashboard:
    theme: 
       - minty
       - styles.scss
    nav-buttons: [github]
    github: https://github.com/Malone-Disturbance-Ecology-Lab/WPBR_app
server: shiny
---
```{r}
#| context: setup

# Load packages
librarian::shelf(shiny, dplyr, leaflet,
                 terra, raster, leafem,
                 htmltools, stringr, mapview,
                 webshot2, quiet = T)

# NOTE: might need to run this in order for the Downloading feature to work
# webshot::install_phantomjs(force = TRUE)

# Read in established model raster
est_raster <- terra::rast("Ensemble_1980-2023_EST.tif")
# Read in invading model raster
inv_raster <- terra::rast("Ensemble_1980-2023_INV.tif")

# Rename each layer to just the year for both models
names(est_raster) <- stringr::str_replace(names(est_raster), "est-", "")
names(inv_raster) <- stringr::str_replace(names(inv_raster), "inv-", "")
```

# {.sidebar}

```{r}
# Drop-down menu to select the model
selectInput(
  inputId = "model_select",
  label = "Model",
  choices = list("Established Model" = 1, "Invading Model" = 2),
  selected = 1
) 
```

```{r}
# Drop-down menu to select the year
selectInput(
  inputId = "year_select",
  label = "Year",
  choices = 1980:2023,
  selected = 1980
) 
```

```{r}
# Download button to download a picture of the map
downloadButton(outputId = "dl")
```

# Map 
```{r}
# Our Leaflet map will show up in the "Plot" tab
leafletOutput(outputId = "map")
```


```{r}
#| context: server

# Pick out the model that corresponds to the user's selection
raster_model <- reactive({
  if (input$model_select == "1") {
    return(est_raster)
  }
  
  if (input$model_select == "2") {
    return(inv_raster)
  }
})

# Pick out the raster layer that corresponds to the model and year the user selects
raster_layer <- reactive({
  raster_model()[[input$year_select]]
})

# Create the foundational Leaflet map
foundational_map <- reactive({
  # Set the color palette of the raster layer plot
  pal <- leaflet::colorNumeric(
    palette = "viridis",
    domain = terra::values(raster_layer()),
    na.color = "transparent"
  )
  
  leaflet() %>%
    # Add Leaflet-provided gray background map
    leaflet::addProviderTiles(providers$CartoDB.Positron, group = "Gray background") %>%
    # Add Leaflet-provided terrain map
    leaflet::addProviderTiles("Esri.WorldImagery", group = "Imagery") %>%
    # Add raster layer plot
    leaflet::addRasterImage(group = "WPBR risk", raster_layer(), colors = pal) %>%
    # Add legend for raster layer
    leaflet::addLegend(
      group = "WPBR risk",
      data = raster_layer(),
      pal = pal,
      values = terra::values(raster_layer()),
      position = "bottomleft",
      title = "Probability of rust"
    ) %>%
    # Add lat/lon coordinate indicator
    leafem::addMouseCoordinates() %>%
    # Add mouseover popup that shows the value of the raster layer
    leafem::addImageQuery(
      x = raster::raster(raster_layer()),
      group = "WPBR risk",
      position = "bottomright"
    ) %>%
    # Set the layer control
    leaflet::addLayersControl(
      baseGroups = c("Gray background", "Imagery"),
      overlayGroups = c("WPBR risk"),
      options = layersControlOptions(collapsed = FALSE)
    )
})

# Render the foundational Leaflet map
output$map <- leaflet::renderLeaflet({
  foundational_map()
})

# store the current user-created version of the Leaflet map for download in a reactive expression
# https://stackoverflow.com/questions/44259716/how-to-save-a-leaflet-map-in-shiny

user_created_map <- reactive({
  # If the map is toggled to "Imagery" and "WPBR risk" layers, show those layers in the download
  if (identical(x = c("Imagery", "WPBR risk"), y = input$map_groups)) {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::showGroup(group = c("Imagery", "WPBR risk"))
    
    return(user_created_map)
    
    # Else if the map is toggled to "Gray background" and "WPBR risk" layers, show those layers in the download
  } else if (identical(x = c("Gray background", "WPBR risk"), y = input$map_groups)) {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::showGroup(group = c("Gray background", "WPBR risk"))
    
    return(user_created_map)
    
    # Else if the map is toggled to only the "Imagery" layer, show only that layer in the download
  } else if (input$map_groups == "Imagery") {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::hideGroup(group = c("WPBR risk")) %>%
      leaflet::showGroup(group = c("Imagery"))
    
    return(user_created_map)
    
    # Else if the map is toggled to only the "Gray background" layer, show only that layer in the download
  } else if (input$map_groups == "Gray background") {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::hideGroup(group = c("WPBR risk")) %>%
      leaflet::showGroup(group = c("Gray background"))
    
    return(user_created_map)
    
  }
  
})

output$dl <- downloadHandler(
  # Create the output file name
  filename = paste0(Sys.Date(), "_custom_map", ".png"),
  
  content = function(file) {
    # Tell the download button to take a screenshot with mapview::mapshot2()
    mapview::mapshot2(x = user_created_map(),
                      file = file,
                      # Match the height & width from the viewing port to clipping rectangle
                      cliprect = "viewport")
  }
)

```


