---
title: "RustMapper: White Pine Blister Rust (WPBR) Risk"
format: 
  dashboard:
    theme: 
       - minty
       - styles.scss
    nav-buttons: [github]
    github: https://github.com/Malone-Disturbance-Ecology-Lab/WPBR_app
server: shiny
---
```{r}
#| context: setup

# Load packages
librarian::shelf(shiny, dplyr, leaflet,
                 terra, raster, leafem,
                 htmltools, stringr, mapview,
                 webshot2, quiet = T)

# NOTE: might need to run this in order for the Downloading feature to work
# webshot::install_phantomjs(force = TRUE)

# Read in established model raster
est_raster <- terra::rast("Ensemble_1980-2023_EST.tif")
# Read in invading model raster
inv_raster <- terra::rast("Ensemble_1980-2023_INV.tif")

# Rename each layer to just the year for both models
names(est_raster) <- stringr::str_replace(names(est_raster), "est-", "")
names(inv_raster) <- stringr::str_replace(names(inv_raster), "inv-", "")
```

# Map

## {.sidebar}

```{r}
# Drop-down menu to select the model
selectInput(
  inputId = "model_select",
  label = "Model",
  choices = list("Established Model" = 1, "Invading Model" = 2),
  selected = 1
) 
```

```{r}
# Drop-down menu to select the year
selectInput(
  inputId = "year_select",
  label = "Year",
  choices = 1980:2023,
  selected = 1980
) 
```

```{r}
# Download button to download a picture of the map
downloadButton(outputId = "dl", label = "Map Download")
```

Current map coordinates:

```{r}
# Show current map coordinates
textOutput("current_coords_w")
textOutput("current_coords_e")
textOutput("current_coords_s")
textOutput("current_coords_n")
```

## Row 

```{r}
# Our Leaflet map will show up in the "Map" tab
leafletOutput(outputId = "map")
```


```{r}
#| context: server

# Pick out the model that corresponds to the user's selection
raster_model <- reactive({
  if (input$model_select == "1") {
    return(est_raster)
  }
  
  if (input$model_select == "2") {
    return(inv_raster)
  }
})

# Pick out the raster layer that corresponds to the model and year the user selects
raster_layer <- reactive({
  raster_model()[[input$year_select]]
})

# Create the foundational Leaflet map
foundational_map <- reactive({
  # Set the color palette of the raster layer plot
  pal <- leaflet::colorNumeric(
    palette = "viridis",
    domain = terra::values(raster_layer()),
    na.color = "transparent"
  )
  
  leaflet() %>%
    # Add Leaflet-provided gray background map
    leaflet::addProviderTiles(providers$CartoDB.Positron, group = "Gray background") %>%
    # Add Leaflet-provided terrain map
    leaflet::addProviderTiles("Esri.WorldImagery", group = "Imagery") %>%
    # Add raster layer plot
    leaflet::addRasterImage(group = "WPBR risk", raster_layer(), colors = pal) %>%
    # Add legend for raster layer
    leaflet::addLegend(
      group = "WPBR risk",
      data = raster_layer(),
      pal = pal,
      values = terra::values(raster_layer()),
      position = "bottomleft",
      title = "Probability of rust"
    ) %>%
    # Add lat/lon coordinate indicator
    leafem::addMouseCoordinates() %>%
    # Add mouseover popup that shows the value of the raster layer
    leafem::addImageQuery(
      x = raster::raster(raster_layer()),
      group = "WPBR risk",
      position = "bottomright"
    ) %>%
    # Set the layer control
    leaflet::addLayersControl(
      baseGroups = c("Gray background", "Imagery"),
      overlayGroups = c("WPBR risk"),
      options = layersControlOptions(collapsed = FALSE)
    )
})

# Render the foundational Leaflet map
output$map <- leaflet::renderLeaflet({
  foundational_map()
})

# store the current user-created version of the Leaflet map for download in a reactive expression
# https://stackoverflow.com/questions/44259716/how-to-save-a-leaflet-map-in-shiny

user_created_map <- reactive({
  # If the map is toggled to "Imagery" and "WPBR risk" layers, show those layers in the download
  if (identical(x = c("Imagery", "WPBR risk"), y = input$map_groups)) {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::showGroup(group = c("Imagery", "WPBR risk"))
    
    return(user_created_map)
    
    # Else if the map is toggled to "Gray background" and "WPBR risk" layers, show those layers in the download
  } else if (identical(x = c("Gray background", "WPBR risk"), y = input$map_groups)) {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::showGroup(group = c("Gray background", "WPBR risk"))
    
    return(user_created_map)
    
    # Else if the map is toggled to only the "Imagery" layer, show only that layer in the download
  } else if (input$map_groups == "Imagery") {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::hideGroup(group = c("WPBR risk")) %>%
      leaflet::showGroup(group = c("Imagery"))
    
    return(user_created_map)
    
    # Else if the map is toggled to only the "Gray background" layer, show only that layer in the download
  } else if (input$map_groups == "Gray background") {
    # Call the foundational Leaflet map
    user_created_map <- foundational_map() %>%
      # Store the view based on UI
      leaflet::setView(
        lng = input$map_center$lng,
        lat = input$map_center$lat,
        zoom = input$map_zoom
      ) %>%
      # Show only the layer(s) the user toggled to
      leaflet::hideGroup(group = c("WPBR risk")) %>%
      leaflet::showGroup(group = c("Gray background"))
    
    return(user_created_map)
    
  }
  
})

# Output the current coordinates on the map
output$current_coords_w <- renderText({
  paste0("West: ", input$map_bounds$west)
})

output$current_coords_e <- renderText({
  paste0("East: ", input$map_bounds$east)
})

output$current_coords_s <- renderText({
  paste0("South: ", input$map_bounds$south)
})

output$current_coords_n <- renderText({
  paste0("North: ", input$map_bounds$north)
})

output$dl <- downloadHandler(
  # Create the output file name
  filename = paste0(Sys.Date(), "_custom_map", ".png"),
  
  content = function(file) {
    # Tell the download button to take a screenshot with mapview::mapshot2()
    mapview::mapshot2(x = user_created_map(),
                      file = file,
                      # Match the height & width from the viewing port to clipping rectangle
                      cliprect = "viewport")
  }
)

```


# Data

## {.sidebar}

Get summary stats for a specific model over a time period and spatial area: 

```{r}
# Drop-down menu to select the model
selectInput(
  inputId = "summary_model_select",
  label = "Model for summary",
  choices = list("Established Model" = 1, "Invading Model" = 2),
  selected = 1
) 

# Input: Specify the range of years you want
sliderInput(inputId = "range", label = "Range:",
            min = 1980, max = 2023,
            value = c(1980,1990), sep = "")

# Input: Specify the coordinates for the spatial area you want
numericInput(inputId = "west_coord", label = "West coordinate:", terra::ext(est_raster)[1])

numericInput(inputId = "east_coord", label = "East coordinate:", terra::ext(est_raster)[2])

numericInput(inputId = "south_coord", label = "South coordinate:", terra::ext(est_raster)[3])

numericInput(inputId = "north_coord", label = "North coordinate:", terra::ext(est_raster)[4])

# Download button to download a csv of the summary dataframe
downloadButton(outputId = "dl2", label = "Data Download")
```

## Row 
```{r}
# Our summary table will show up in the "Summary" tab
tableOutput(outputId = "values")
```

```{r}
#| context: server

# Pick out the model that corresponds to the user's selection
summary_raster_model <- reactive({
  if (input$summary_model_select == "1") {
    return(est_raster)
  }
  
  if (input$summary_model_select == "2") {
    return(inv_raster)
  }
})

# Get the name of the selected model
summary_raster_model_name <- reactive({
  if (input$summary_model_select == "1") {
    return("Established")
  }
  
  if (input$summary_model_select == "2") {
    return("Invading")
  }
})

# Create a SpatVector with our selected bounds
polygon_shape <- reactive({
  e <- terra::ext(input$west_coord,
                  input$east_coord,
                  input$south_coord,
                  input$north_coord)
  p <- terra::as.polygons(e, crs = "epsg:4326")
  return(p)
})

# Find the numeric index of the layer that has the starting year
start_year <- reactive({
  start_index <- which(names(summary_raster_model()) == as.character(input$range[1]))
  return(start_index)
})

# Find the numeric index of the layer that has the ending year
end_year <- reactive({
  end_index <- which(names(summary_raster_model()) == as.character(input$range[2]))
  return(end_index)
})

# Calculate the mean risk for the specified time interval and spatial area
raster_mean <- reactive({
  mean_values <- terra::extract(summary_raster_model()[[start_year():end_year()]],
                                polygon_shape(),
                                mean,
                                na.rm = TRUE,
                                ID = FALSE)
  return(base::t(mean_values))
})

# Assemble the dataframe
table_summary <- reactive({
  data.frame(
    Model = summary_raster_model_name(),
    Year = input$range[1]:input$range[2],
    Mean = raster_mean(),
    West = input$west_coord,
    East = input$east_coord,
    South = input$south_coord,
    North = input$north_coord
  )
})

# Show the values in an HTML table
output$values <- renderTable({
  table_summary()
})

output$dl2 <- downloadHandler(
  # Create the output file name
  filename = function() {
    paste0(Sys.Date(), "_custom_summary.csv")
  },
  
  content = function(file) {
    # Tell the download button to export the summary dataframe as a csv
    write.csv(table_summary(), file, row.names = FALSE)
  }
)
```